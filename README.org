* CL-CPP-GENERATOR
  
** Introduction
This project provides the Common Lisp function ~emit-cpp &key code
str~. It receives a list of special s-expressions and emits
corresponding C++ code into a string.


** Installation

Clone the repository into Quicklisps local-projects folder:

#+BEGIN_SRC
cd ~/quicklisp/local-projects
git clone https://github.com/plops/cl-cpp-generator
#+END_SRC

If you want to add the code to a lisp that is alreay running, you will have to call:

#+BEGIN_SRC common-lisp
(ql:register-local-projects)
#+END_SRC

I don't think this is required if you start a new instance of Common
Lisp. In that case quicklisp will find the new folder during its
initialization.


Place the following code into a .lisp file and execute the file, i.e. in Slime press C-c C-k.


#+BEGIN_SRC common-lisp
(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload :cl-cpp-generator))

(in-package :cl-cpp-generator)

(with-open-file (s "emitted_code.cpp"
                   :direction :output
                   :if-exists :supersede
                   :if-does-not-exist :create)
  (emit-cpp
   :str s
   :clear-env t
   :code 
   `(with-compilation-unit
          (include <optixu/optixpp_namespace.h>))))
#+END_SRC

This will output a line with an include statement into the file
emitted_code.cpp.  To write more you can add additional code in in the
with-compilation-unit expression and re-execute the surrounding
with-open-file with C-M-x.

** Using macros

This an example to that defines and uses a macro:

#+BEGIN_SRC common-lisp
(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload :cl-cpp-generator))

(in-package :cl-cpp-generator)

(defmacro with-glfw-window ((win &key (w 512) (h 512) (title "glfw")) &body body)
  `(let ((,win :type GLFWwindow*))
     (if (! (funcall glfwInit))
	 (statements (return -1)))
     (setf ,win (funcall glfwCreateWindow ,w ,h (string ,title) NULL NULL))
     (if (! ,win)
	 (statements (funcall glfwTerminate)
		     (return -1)))
     (funcall glfwMakeContextCurrent ,win)
     ,@body
     (funcall glfwTerminate)))


(with-open-file (s "emitted_code.cpp"
		      :direction :output
		      :if-exists :supersede
		      :if-does-not-exist :create)
     (emit-cpp
      :str s
      :clear-env t
      :code 
      `(with-compilation-unit

	   (function (main ((argc :type int)
			    (argv :type char**))
			   int)
	    (decl ((argc :type (void))))
	    (decl ((argv :type (void))))
	    (macroexpand
	     (with-glfw-window (main_window :w 512 :h 512)
	       (for (() (! (funcall glfwWindowShouldClose main_window)) ())

		    (funcall glClear GL_COLOR_BUFFER_BIT)
		    
		       
		    (funcall glfwSwapBuffers main_window)
		    
		    (funcall glfwPollEvents))))
	    (return 0)))))
#+END_SRC

** Support for ISPC (Intel SPMD Program Compiler) 

If you add the keyword ispc to `*features*`, you can use the ispc
specific control expressions (foreach, foreach_unique, foreach_tiled,
foreach_active, cif, bit).

#+BEGIN_SRC common-lisp
(push :ispc *features*)
(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload :cl-cpp-generator))

(in-package :cl-cpp-generator)
(with-output-to-string (s)
  (emit-cpp
   :str s
   :clear-env t
   
   :code 
   `(with-compilation-unit
	(dotimes (i (funcall max 2 3))
	  (funcall bla))
      (foreach (i (funcall max  1 0) (funcall min m n))
	       (funcall ata))
      (foreach ((i (funcall max  1 0) (funcall min m n))
		(j 0 n))
	       (funcall ata))
      (foreach-active (i)
		      (+= (aref a index) (bit #b0110)))
      (function (func ((v :type "uniform int")) "extern void"))
      (foreach-unique (val x)
	       (funcall func val)))))
#+END_SRC

#+BEGIN_SRC c++
for(int i = 0; (i < max(2,3)); i += 1) {
  bla();
}

foreach(i = max(1,0) ... min(m,n)) {
  ata();
}

foreach(i = max(1,0) ... min(m,n),j = 0 ... n) {
  ata();
}

foreach_active(i) {
  a[index] += 0b110;
}

extern void func(uniform int v);
foreach_uniq(val in x) {
  func(val);
}
#+END_SRC



** Example

#+BEGIN_SRC common-lisp
(with-open-file (s "o.cpp"
                   :direction :output
                   :if-exists :supersede
                   :if-does-not-exist :create)
  (emit-cpp :str s :code
            '(with-compilation-unit
              (include <complex>)
              (include "org_types.h")
              (with-namespace N
                (class CommandsHandler ()
                 (access-specifier public)
                 (constructord CommandsHandler ((callbacks :type "const DeviceCallbacks")))
                 (functiond HandleRxBlock ((data :type "const uint16_t")) void))
                (function HandleRxBlock ((data :type "const uint16_t")) void
                 (decl ((a :type uint16_t :init 3)
                        (b :type uint16_t)))
                 (+= a data))))))
#+END_SRC

#+BEGIN_SRC c++
#include "org_types.h"
#include <complex>
namespace N {
class CommandsHandler {
public:
  CommandsHandler(const DeviceCallbacks callbacks);
  void HandleRxBlock(const uint16_t data);

}

void HandleRxBlock(const uint16_t data){
  uint16_t a = 3;
  uint16_t b;
  ;
  a += data;
}
};
#+END_SRC

include arg
 arg either keyword like <stdio.h> or a string

function name params* ret expr1 expr2 ... 
name .. function name
parameters .. 0 or more but always a list
ret .. return value


constructord name params*
functiond name params* ret expr ..



struct
union
class identifier base-clause
identifier .. class name like dfa%%flash
base-clause .. (()) or ((public virtual buh%%fcsdf)) or ((public virtual buh%%fcsdf) (private B::C))

with-namespace name &rest cmds

with-compilation-unit &rest cmds

binary operator (+ a  b c) 
a + b + c

setf a b c d
a = b; c = d

computed assignemnt a b
a += b

logical operator ==
a == b

compound-statement (a b c)
{
 a;
 b;
 c;
}

decl ((name :type type :init 0) ( .. ) (.. ) .. )

type name = 0;


let 
just like lisp, expands into block with decl inside

if cond yes [no]

for
(for ((i a :type int) (< i n) (+= i 1)))
for(int i=a;i<n;i+=1)

i only allow one variable initialization


statement 
ensure a semicolon at the end



TAGBODY {tag | statement}*

Define tags for use with GO. The STATEMENTS are evaluated in order, skipping
TAGS, and NIL is returned. If a statement contains a GO to a defined TAG
within the lexical scope of the form, then control is transferred to the next
statement following that tag. A TAG must be an integer or a symbol. A
STATEMENT must be a list. Other objects are illegal within the body.




** References

- how to write a dsl in lisp: https://www.youtube.com/watch?v=5FlHq_iiDW0

- http://voodoo-slide.blogspot.de/2010/01/amplifying-c.html

- https://github.com/burtonsamograd/sxc

- https://github.com/shirok/Gauche/blob/master/lib/gauche/cgen/cise.scm

- https://news.ycombinator.com/item?id=13199610

- https://github.com/kiselgra/c-mera

- https://github.com/eratosthenesia/lispc
  
- https://github.com/cbaggers/varjo
