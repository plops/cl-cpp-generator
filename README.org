* CL-CPP-GENERATOR
  
** Introduction
This project provides the Common Lisp function ~emit-cpp &key code
str~. It receives a list of special s-expressions and emits
corresponding C++ code into a string.

Here are links to some bigger projects that make use of
cl-cpp-generator. The gen.lisp file contains additional macros and the
generating function. The output files are in the source/ folder in the
repository:


- Interactive programming example: Open a GLFW window and dlopens a library that emits OpenGL calls. This library source can be modified/recompiled/reloaded while the program keeps running. https://github.com/plops/cl-gen-glfw

- emit C++ code with Intel Threading Building Blocks and Intel ISPC SIMD compiler that computes the mandelbrot set: https://github.com/plops/cl-gen-ispc-mandelbrot





** Installation

Clone the repository into Quicklisps local-projects folder:

#+BEGIN_SRC
cd ~/quicklisp/local-projects
git clone https://github.com/plops/cl-cpp-generator
#+END_SRC

If you want to add the code to a lisp that is alreay running, you will have to call:

#+BEGIN_SRC common-lisp
(ql:register-local-projects)
#+END_SRC

I don't think this is required if you start a new instance of Common
Lisp. In that case quicklisp will find the new folder during its
initialization.

I develop with SBCL, so for now that is the only supported implementation.

Place the following code into a .lisp file and execute the file, i.e. in Slime press C-c C-k.


#+BEGIN_SRC common-lisp
(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload :cl-cpp-generator))

(in-package :cl-cpp-generator)

(with-open-file (s "emitted_code.cpp"
                   :direction :output
                   :if-exists :supersede
                   :if-does-not-exist :create)
  (emit-cpp
   :str s
   :clear-env t
   :code 
   `(with-compilation-unit
          (include <optixu/optixpp_namespace.h>))))
#+END_SRC

This will output a line with an include statement into the file
emitted_code.cpp.  To write more you can add additional code in in the
with-compilation-unit expression and re-execute the surrounding
with-open-file with C-M-x.


** Using macros

This an example to that defines and uses a macro. emit-cpp calls the
macroexpand of the host compiler. That is why either defmacro or
macrolet can be used to define the macro.

#+BEGIN_SRC common-lisp
(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload :cl-cpp-generator))

(in-package :cl-cpp-generator)

(defmacro with-glfw-window ((win &key (w 512) (h 512) (title "glfw")) &body body)
  `(let ((,win :type GLFWwindow*))
     (if (! (funcall glfwInit))
	 (statements (return -1)))
     (setf ,win (funcall glfwCreateWindow ,w ,h (string ,title) NULL NULL))
     (if (! ,win)
	 (statements (funcall glfwTerminate)
		     (return -1)))
     (funcall glfwMakeContextCurrent ,win)
     ,@body
     (funcall glfwTerminate)))


(with-open-file (s "emitted_code.cpp"
		      :direction :output
		      :if-exists :supersede
		      :if-does-not-exist :create)
     (emit-cpp
      :str s
      :clear-env t
      :code 
      `(with-compilation-unit

	   (function (main ((argc :type int)
			    (argv :type char**))
			   int)
	    (decl ((argc :type (void))))
	    (decl ((argv :type (void))))
	    (macroexpand
	     (with-glfw-window (main_window :w 512 :h 512)
	       (for (() (! (funcall glfwWindowShouldClose main_window)) ())

		    (funcall glClear GL_COLOR_BUFFER_BIT)
		    
		       
		    (funcall glfwSwapBuffers main_window)
		    
		    (funcall glfwPollEvents))))
	    (return 0)))))
#+END_SRC

** Support for ISPC (Intel SPMD Program Compiler) 

If you add the keyword ispc to `*features*`, you can use the ispc
specific control expressions (foreach, foreach_unique, foreach_tiled,
foreach_active, cif, bit).

#+BEGIN_SRC common-lisp
(push :ispc *features*)
(eval-when (:compile-toplevel :execute :load-toplevel)
  (ql:quickload :cl-cpp-generator))

(in-package :cl-cpp-generator)
(with-output-to-string (s)
  (emit-cpp
   :str s
   :clear-env t
   
   :code 
   `(with-compilation-unit
	(dotimes (i (funcall max 2 3))
	  (funcall bla))
      (foreach (i (funcall max  1 0) (funcall min m n))
	       (funcall ata))
      (foreach ((i (funcall max  1 0) (funcall min m n))
		(j 0 n))
	       (funcall ata))
      (foreach-active (i)
		      (+= (aref a index) (bit #b0110)))
      (function (func ((v :type "uniform int")) "extern void"))
      (foreach-unique (val x)
	       (funcall func val)))))
#+END_SRC

#+BEGIN_SRC c++
for(int i = 0; (i < max(2,3)); i += 1) {
  bla();
}

foreach(i = max(1,0) ... min(m,n)) {
  ata();
}

foreach(i = max(1,0) ... min(m,n),j = 0 ... n) {
  ata();
}

foreach_active(i) {
  a[index] += 0b110;
}

extern void func(uniform int v);
foreach_uniq(val in x) {
  func(val);
}
#+END_SRC



** Example

#+BEGIN_SRC common-lisp
(with-open-file (s "o.cpp"
                   :direction :output
                   :if-exists :supersede
                   :if-does-not-exist :create)
  (emit-cpp :str s :code
            '(with-compilation-unit
              (include <complex>)
              (include "org_types.h")
              (with-namespace N
                (class CommandsHandler ()
                 (access-specifier public)
                 (constructord CommandsHandler ((callbacks :type "const DeviceCallbacks")))
                 (functiond HandleRxBlock ((data :type "const uint16_t")) void))
                (function HandleRxBlock ((data :type "const uint16_t")) void
                 (decl ((a :type uint16_t :init 3)
                        (b :type uint16_t)))
                 (+= a data))))))
#+END_SRC

#+BEGIN_SRC c++
#include "org_types.h"
#include <complex>
namespace N {
class CommandsHandler {
public:
  CommandsHandler(const DeviceCallbacks callbacks);
  void HandleRxBlock(const uint16_t data);

}

void HandleRxBlock(const uint16_t data){
  uint16_t a = 3;
  uint16_t b;
  ;
  a += data;
}
};
#+END_SRC

include arg
 arg either keyword like <stdio.h> or a string

function name params* ret expr1 expr2 ... 
name .. function name
parameters .. 0 or more but always a list
ret .. return value


constructord name params*
functiond name params* ret expr ..



struct
union
class identifier base-clause
identifier .. class name like dfa%%flash
base-clause .. (()) or ((public virtual buh%%fcsdf)) or ((public virtual buh%%fcsdf) (private B::C))

with-namespace name &rest cmds

with-compilation-unit &rest cmds

binary operator (+ a  b c) 
a + b + c

setf a b c d
a = b; c = d

computed assignemnt a b
a += b

logical operator ==
a == b

compound-statement (a b c)
{
 a;
 b;
 c;
}

decl ((name :type type :init 0) ( .. ) (.. ) .. )

type name = 0;


let 
just like lisp, expands into block with decl inside

if cond yes [no]

for
(for ((i a :type int) (< i n) (+= i 1)))
for(int i=a;i<n;i+=1)

i only allow one variable initialization


statement 
ensure a semicolon at the end



TAGBODY {tag | statement}*

Define tags for use with GO. The STATEMENTS are evaluated in order, skipping
TAGS, and NIL is returned. If a statement contains a GO to a defined TAG
within the lexical scope of the form, then control is transferred to the next
statement following that tag. A TAG must be an integer or a symbol. A
STATEMENT must be a list. Other objects are illegal within the body.




** Development with multiple output files

Usually I develop my code emitter in one common lisp progn that writes
all required files upon execution with C-M-x in Slime.  Often it is
necessary to write into multiple output files. However, writing the
same content into a file still changes the modification time and
induces a rebuild in make or ninja. The following function
write-source hashes the output of each call in '*file-hashes*' and will not emit code of
unmodified s-expressions into C source code.

Note: The data in '*file-hashes*' is not persistent. So if you run this
code in a fresh Common Lisp instance all C files will be touched and
require rebuild. If you want to prevent that store '*file-hashes*' to
disk.

#+BEGIN_SRC common-lisp
(defparameter *file-hashes* (make-hash-table))

(defun write-source (name extension code)
  (let* ((fn (merge-pathnames (format nil "~a.~a" name extension)
                              (user-homedir-pathname)))
         (code-str (emit-cpp
                    :clear-env t
                    :code code))
         (fn-hash (sxhash fn))
         (code-hash (sxhash code-str)))
    (multiple-value-bind (old-code-hash exists) (gethash fn-hash *file-hashes*)
      (when (or (not exists) (/= code-hash old-code-hash))
        ;; store the sxhash of the c source in the hash table
        ;; *file-hashes* with the key formed by the sxhash of the full
        ;; pathname
        (setf (gethash fn-hash *file-hashes*) code-hash)
        (with-open-file (s fn
                           :direction :output
                           :if-exists :supersede
                           :if-does-not-exist :create)
          (write-sequence code-str s))
        (sb-ext:run-program "/usr/bin/clang-format" (list "-i" (namestring fn)))))))


(let ((header `(with-compilation-unit
                   (include <QGraphicsItemGroup>)
                 (class CustomItemGridGroup ("public QGraphicsItemGroup")
                        (access-specifier public)
                        (function (CustomItemGridGroup ((dx :type int)
                                                        (dy :type int)
                                                        (nx :type int)
                                                        (ny :type int))
                                                       explicit))
                        
                        (access-specifier private)
                        (decl ((m_dx :type "unsigned int")
                               (m_dy :type "unsigned int")
                               (m_nx :type "unsigned int")
                               (m_ny :type "unsigned int"))))))
      (code `(with-compilation-unit
                 (include "CustomItemGridGroup.h")
               (function ("CustomItemGridGroup::CustomItemGridGroup" ((dx :type int)
                                                                      (dy :type int)
                                                                      (nx :type int)
                                                                      (ny :type int))
                                                                     nil
                                                                     :ctor
                                                                     ((m_dx dx)
                                                                      (m_dy dy)
                                                                      (m_nx nx)
                                                                      (m_ny ny)))
                         (with-compilation-unit
                             (raw "// draw grid")
                           (let ((dx :init m_dx)
                                 (dy :init m_dy)
                                 (nx :init m_nx)
                                 (ny :init m_ny))
                             (dotimes (i ny)
                               (let ((x1 :init (* dx i))
                                     (y1 :init (* dy 0))
                                     (x2 :init x1)
                                     (y2 :init (* dy (- ny 1))))
                                 (funcall this->addToGroup (new (funcall QGraphicsLineItem (funcall QLineF x1 y1 x2 y2))))))
                             (dotimes (i nx)
                               (let ((y1 :init (* dy i))
                                     (x1 :init (* dx 0))
                                     (y2 :init y1)
                                     (x2 :init (* dx (- nx 1))))
                                 (funcall this->addToGroup (new (funcall QGraphicsLineItem (funcall QLineF x1 y1 x2 y2))))))))))))
  (write-source "CustomItemGridGroup" "h" header)
  (write-source "CustomItemGridGroup" "cpp" code))
#+END_SRC

#+BEGIN_SRC c++
// cpp 
#include "CustomItemGridGroup.h"
CustomItemGridGroup::CustomItemGridGroup(int dx, int dy, int nx, int ny)
    : m_dx(dx), m_dy(dy), m_nx(nx), m_ny(ny) {
  // draw grid
  {
    auto dx = m_dx;
    auto dy = m_dy;
    auto nx = m_nx;
    auto ny = m_ny;

    for (unsigned int i = 0; (i < ny); i += 1) {
      {
        auto x1 = (dx * i);
        auto y1 = (dy * 0);
        auto x2 = x1;
        auto y2 = (dy * (ny - 1));

        this->addToGroup(new QGraphicsLineItem(QLineF(x1, y1, x2, y2)));
      }
    }

    for (unsigned int i = 0; (i < nx); i += 1) {
      {
        auto y1 = (dy * i);
        auto x1 = (dx * 0);
        auto y2 = y1;
        auto x2 = (dx * (nx - 1));

        this->addToGroup(new QGraphicsLineItem(QLineF(x1, y1, x2, y2)));
      }
    }
  }
}

// header
#include <QGraphicsItemGroup>
class CustomItemGridGroup : public QGraphicsItemGroup {
public:
  explicit CustomItemGridGroup(int dx, int dy, int nx, int ny);

private:
  unsigned int m_dx;
  unsigned int m_dy;
  unsigned int m_nx;
  unsigned int m_ny;
};
#+END_SRC


** Implementation of tests

In order to verify that the code emitted by emit-cpp is valid I
implemented unit tests in test.lisp. I also use sb-cover to create an
HTML code coverage report.

The function (test <number> <code> <string>) will emit C code as
defined by the s-expression in <code> using the emit-cpp function into
/dev/shm/1. 

The expected output is given to the test function as the third
parameter <string> and is written into /dev/shm/2.

Both files are then indented with clang-format so that the test is
less independent on the exact white space. Then the files are compared
using the diff command.

*** How to fix a broke test

If the emit-cpp output is not the same as the expected <string>, an
assertion error like this will show up:

#+BEGIN_SRC
The assertion
(eq nil
    #1=(with-output-to-string (s)
         (sb-ext:run-program "/usr/bin/diff"
                             '("/dev/shm/1" "/dev/shm/2")
                             :output s)))
failed with #1# = "2,5c2,5
< float f = (3.2e-7);
< double d = (7.2e-31);
< complex float z = ((2.f+0) + (1.f+0i));
< complex double w = ((2.e+0) + (1.e+0i));
---
> float f = (3.2000000000f-7);
> double d = (7.200000000000000000e-31);
> complex float z = ((2.0000000000f+0) + (1.0000000000f+0i));
> complex double w = ((2.000000000000000000e+0) + (1.000000000000000000e+0i));
".
#+END_SRC

In this case I modified the printing of floating point numbers in
emit-cpp, so that the least amount of digits are printed without
loosing precision. Of course this broke the previous test. If the code
in /dev/shm/1 is correct, just place it into the third argument
<string> of test. Don't forget to quote quotes.

** Problem

#+BEGIN_SRC
(if (== current_pattern_number pattern_number) ...

source/libview.cpp:265:41: warning: equality comparison with extraneous parentheses
      [-Wparentheses-equality]
            if ((current_pattern_number == pattern_number)) {
                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
source/libview.cpp:265:41: note: remove extraneous parentheses around the comparison to silence this
      warning
            if ((current_pattern_number == pattern_number)) {
                ~                       ^                ~
source/libview.cpp:265:41: note: use '=' to turn this equality comparison into an assignment
            if ((current_pattern_number == pattern_number)) {
                                        ^~
                                        =

#+END_SRC


** Ideas

*** Destructuring

- http://stackoverflow.com/questions/31394507/how-can-i-emulate-destructuring-in-c

#+BEGIN_SRC
 struct animal {
     std::string species;
     int weight;
     std::string sound;
 };

 int main()
 {
   auto pluto = animal { "dog", 23, "woof" };

   auto [ species, weight, sound ] = pluto;

   std::cout << "species=" << species << " weight=" << weight << " sound=" << sound << "\n";
 }
#+END_SRC

** References



- how to write a dsl in lisp: https://www.youtube.com/watch?v=5FlHq_iiDW0

- https://github.com/deplinenoise/c-amplify (CL)
http://voodoo-slide.blogspot.de/2010/01/amplifying-c.html


- https://github.com/burtonsamograd/sxc (CL)
 https://news.ycombinator.com/item?id=13199610
the syntax is structured in a way that, though it resembles C, so that
  it is quickly readable if you know C, seems to be hard to analyze
  for rudimentary structure in a way that follows semantics.

[he] wrote the syntax as [he] went along going through the examples and
problems of K&R. The syntax is more like C as this is more of a tool
that is meant to bring C programmers into the Lisp world rather than
pulling Lisp programmers into the C world

The expander of a macro is Lisp; its output is SXC.



- http://super.para.media.kyoto-u.ac.jp/~tasuku/sc/index.html (CL)
https://bitbucket.org/tasuku/sc-tascell
http://super.para.media.kyoto-u.ac.jp/%7Etasuku/sc/pub/ppopp09.pdf



- https://github.com/kiselgra/c-mera

- https://github.com/eratosthenesia/lispc
  
- https://github.com/cbaggers/varjo
Baggers: Khronos Meetup Oslo: Lisping on the GPU  https://www.youtube.com/watch?v=XEtlxJsPR40
  
- https://github.com/takagi/cl-cuda

- https://github.com/angavrilov/cl-gpu

  
- https://bitbucket.org/ktg/l (Racket, very concise/nice documentation)  

- https://github.com/shirok/Gauche/blob/master/lib/gauche/cgen/cise.scm

- https://github.com/vsedach/Parenscript

- https://software.intel.com/en-us/articles/the-ultimate-question-of-programming-refactoring-and-everything

- clang tooling https://clang.llvm.org/docs/LibASTMatchersTutorial.html

- Rust/Haskell/Ada Microcontroller https://news.ycombinator.com/item?id=14071282

- Haskel DSL http://ivorylang.org/

- Lisp flavoured C https://github.com/tomhrr/dale
